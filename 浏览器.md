## 一、缓存
强缓存（不需要发送HTTP请求）
1. Expires （过期时间）存在于响应头中。
2. Cache-Control（存在与请求头和响应头中）
  - max-age
  - public
  - private
  - no-cache
  - no-store
  - s-maxage

### 协商缓存（需要发送HTTP请求，在请求头中携带缓存tag，在服务器端决定是否使用缓存）
1. Last-Modified （浏览器第二次发送请求会在请求头中携带：If-Modified-Since）304：用户直接使用缓存
2. ETag 文件生成的唯一标识（浏览器第二次发送请求会在请求头中携带：If-None-Match）304：用户直接使用缓存

### 缓存地址：
1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache


## 二、浏览器本地存储
浏览器本地存储：
1. Cookie
2. WebStorage（localStorage、sessionStorage）
3. IndexDB


## 三、从输入URL到页面呈现发生了什么？

### 网络请求和响应：
1. 构建请求行 GET / HTTP/1.1，同时带上请求头和请求体
2. 查找强缓存
3. DNS解析
4. TCP连接
5. 网络响应
  - 响应行：HTTP/1.1 200 OK
  - 响应头：Set-Cookie、Date、Server、Cache-Control、Connection、Content-Encoding
  - 响应体

Content-Type: text/html
### 解析算法：
1. 构建DOM树  生成方便操作的数据结构
2. 样式计算 CSS文本->结构化对象（styleSheets）
  - 标准化样式属性
  - 计算每个节点的样式  继承、层叠
3. 生成布局树 DOM树+DOM样式 -> 布局树（确定元素的位置）

### 渲染过程：
1. 建立图层树  解决复杂场景：3D动画呈现的变换效果、元素含有层叠上下文时如何控制显示和隐藏等
      - 节点的图层默认属于父节点的图层（合称为合成层）
      - 合称方法：显式合称和隐式合成
      - 显示合称： 1. 层叠上下文 2. 需要裁剪的地方
2. 生成绘制列表
3. 生成图块并删格化
4. 显示器显示内容

## 四、 回流和重绘

### 回流
触发条件：
  - width、height、padding、margin、left、right、border
  - 节点增删
  - 读写offset、scroll、client
  - 调用window.getComputedStyle
需要重新生成DOM树，解析和合成全部需要重新走一遍

### 重绘（repain）：
**window.requestAnimationFrame**

触发条件：样式发生变化，并没有影响几何属性

跳过了生成布局树和建图层树的过程。

## 五、 XSS
跨站脚本，浏览器中执行恶意脚本
- 存储型（存储到了服务器的数据库上）
- 反射性（作为网络请求的一部分）
- 文档型（并不会经过服务器，在数据传输过程劫持到网络数据包，然后修改里面的HTML文档）

### 防范措施：
1. 对用户输入进行转码、过滤
2. 利用CSP（浏览器内容安全策略，服务器决定加载哪些功能）
   - 限制其他域下的资源加载
   - 禁止向其它域提交数据
3. 利用HttpOnly

## 五、 CSRF
CSRF：跨站请求伪造

### 方式：
诱导用户点击链接，打开黑客的网站，利用用户目前的登录状态发起跨站请求。

1. 自动发起GET请求。 `<img src="xxx.com?user=aaa">`
2. 自动发起POST请求。
3. 诱导点击发送GET请求。

### 防范策略：
1. 利用Cookie的SameSit属性。
  - Strict。完全禁止第三方携带Cookie
  - Lax。GET请求可以。
  - None。不限制
2. 验证来源站点。 请求头：**Origin**和**Referer**。
3. CSRF Token。
  - 浏览器发送请求时，服务器生成字符串将其植入返回的页面中。

## 六、 HTTPS
HTTP是**明文传输**，HTTP数据 -> TCP层 -> WIFI路由器 -> 运营商 -> 服务器，中间过程可能被中间人攻击。

HTTPS在HTTP和TCP之间建立了一个**安全层**，将数据**加密**之后传给TCP，TCP也必须将数据**解密**，才能传给上面的HTTP。

安全层的核心就是对数据加解密。

1. 对称加密。加密和解密用的相同密钥。
  - 浏览器 -> 服务器： client_random + 加密方法列表
  - 服务器 -> 浏览器： server_random + 加密方法
  - 用加密方法把这两个随机数混合起来，作为**暗号**
因为用的相同密钥，这个加密方法既能加密也能解密拿到数据。
2. 非对称加密。有A、B两把密钥，A可以解B，B也可以解A。服务器有两把钥匙：公钥和密钥。
  - 浏览器 -> 服务器： client_random + 加密方法列表
  - 服务器 -> 浏览器： server_random + 加密方法 + 公钥
  - 浏览器对用公钥对clien_random和server_random进行加密，生成通信**暗号**。
中间人拿到浏览器的数据，因为没有私钥，无法解密，保证了数据安全。
但相应的问题是：服务器 -> 浏览器数据，只能用私钥加密，中间人拿到公钥，就能进行解密了。
3. 非对称 + 对称结合。
  - 浏览器 -> 服务器： client_random + 加密方法列表
  - 服务器 -> 浏览器： server_random + 加密方法 + 公钥
  - 浏览器生成随机数**pre_random**，并用公钥加密，传给服务器。
  - 服务器用私钥解密，得到**pre_random**
  - 然后浏览器和服务器用一样的公钥进行通信，即对称加密。
中间人没有私钥，拿不到**pre_random**，无法生成最终的密钥。

### 添加数字证书
目的： 让服务器证明自己的身份。

向CA认证，会给服务器颁发数字证书。

作用：
1. 服务器向浏览器证明自己的身份
2. 把公钥传给服务器（数字证书包含了公钥）

读取证书中的明文内容，CA会保存一个Hash函数，这个函数计算明文得到信息A，公钥解密明文得到信息B，两份信息对比一致认证合法。
