# 资源预加载preload、资源预读取prefetch

## 资源优先级
先说一下资源加载的优先级：Chrome浏览器中，不同资源在浏览器渲染的不同阶段进行加载的优先级不同。

其中主资源HTML、CSS的优先级最高，其它资源根据情况优先级不一。

JS脚本根据它们在文件中的位置是否异步、延迟或阻塞获得不同的优先级：
1. 网络在第一个图片资源之前阻塞的脚本在网络优先级中是中级
2. 网络在第一个图片资源之后阻塞的脚本在网络优先级中是低级
3. 异步／延迟／插入的脚本（无论在什么位置）在网络优先级中是很低级

图片（视口可见）将会获得相对于视口不可见图片（低级）的更高的优先级（中级），所以某些程度上 Chrome 将会尽量懒加载这些图片。低优先级的图片在布局完成被视口发现时，将会获得优先级提升

preload 使用 “as” 属性加载的资源将会获得与资源 “type” 属性所拥有的相同的优先级。比如说，preload as="style" 将会获得比 as=“script” 更高的优先级

如果忽略**as**属性，或者错误的 as 属性会使 preload 等同于**XHR**请求，浏览器不知道加载的是什么，因此会赋予此类资源非常低的加载优先级

## preload
**preload**提供了一种声明式命令，让浏览器提前**加载**指定资源（加载后不执行），需要执行时再执行。

这样做的好处：
1. 将**加载**和**执行**windows的**onload**事件
2. 提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出的情况

```
<link rel="preload" href="/path/to/style.css" as="style">
```

- onload事件，可以定义资源加载完毕后的回调函数
- preload 不会阻塞 windows 的**onload**事件
- 对跨域的文件进行preload时，必须加上**crossorigin** 属性

## prefetch
它的作用是告诉浏览器加载下一页面可能会用到的资源，注意，是下一页面，而不是当前页面。因此该方法的加载优先级**非常低**，**利用浏览器的空闲时间去加载**，也就是说该方式的作用是加速下一个页面的加载速度。


## 区别
- preload 是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源
- prefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源